{"posts":[{"title":"算法复杂度分析","text":"什么是算法复杂度算法复杂度是衡量一个算法好坏的标准，一个好的程序应该是用更短的的时间、更小的内存空间来完成一件事，而数据结构和算法就是为了解决“快”和”省“的问题。有了良好的数据结构与算法的基础，我们就能够分析出应该使用的什么样的数据结构来优化程序，用什么样的算法来加速程序。 算法复杂度分为两类： 时间复杂度 空间复杂度 我们通过时间复杂度评价一个算法的耗时级别，用空间复杂度评价一个算法的内存使用级别。当然，我们不能对每一段程序都经过严格计算来统计它的耗时和内存使用情况，我们要的是对整个程序的性能有个大致的了解，至少从它的数量级上进行把握。 程序员的最大乐趣莫过于对一段程序不断优化，每次多提升1s执行时间，少用1M内存，都能给人快乐和成就感。 但是，也有另外一些声音：我们可以把程序跑一遍，然后对时间、空间进行监控，就可以明确知道程序的性能，这样不是更方便吗？ 确实，这样做没毛病。但是，这个做法有明显的缺点： 测试结果依赖测试环境 不同性能的计算机上得到的测试结果是不同的，一个算法的好坏应该有一个统一的评价标准，这个评价标准应该是不受运行它的设备所影响的。 测试结果依赖测试数据规模 在同一台计算机上进行测试时，给同一个算法设定不同的数据规模，得到的结果可能有很大的差别。这样的测试数据结构让我们很难得知算法的实际运行效率是怎样的，我们应该有一个能客观评价算法最好、最坏复杂度的方法。 大O复杂度分析法我们需要一个能评价算法时间、空间复杂度的方法，这个方法应该不受测试环境的影响、也不受测试规模的影响，它应该能反映出一个算法最客观的性能，这种方法就是大O复杂度分析法。 先来看一段简单的代码： 12345678910int fun(int n) { int i = 0; int j = 0; for (int x = 0; x &lt; n; x++) { i += x; for (int y = 0; y &lt; n; y++) { j += y; } }} 现在假设每一行代码的执行时间为一个unit_time，那么上面这段程序的执行时间就是：T(n)=2+2*n+2*n*n 个unit_time：第2、3行代码执行了1遍；第4、5行代码执行了n遍，第6、7行代码执行了n*n遍。按照这种方法我们可以分析得出所有程序执行所需要的unit_time，但是这种方法并不简洁，我们想要通过一种简洁的方法得出算法的性能。 按照上面的规律可以看出，程序执行的时间和每行代码执行的次数之间是正比关系，所以代码的执行时间可以通过分析每行代码执行的次数来得到。 代码的执行时间和代码行数的执行次数之间的关系可以记为： T(n)=O(f(n)) 。其中，T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和，因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。 所以上面的例子就可以表示为：**T(n)=O(2n^2^ + 2n + 2)**。 这就是大O时间复杂度，大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称时间复杂度。 时间复杂度大 O 复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。 还是上面那段代码，如果我们忽略掉常量、低阶、系数，那么这段代码的时间复杂度就是：T(n)=O(n^2^)。 同样的，我们可以分析一下下面这段代码： 123456789101112131415int fun(int a, int b) { int c = 0; for (int i = 0; i &lt; a; i++) { for (int j = 0; j &lt; b; j++) { c += j; } } int d = 0; while (a &gt; 0) { for (int i = 0; i &lt; a; i++) { d += 1; } a--; }} 这段代码已经是比较困难的了，不过我们可以慢慢分析： 第2行代码只执行了1次，T=1 第3行代码只执行了a次，T=a 第4、5行代码执行了a*b次，T=ab 第8行代码执行了1次，T=1 第9、13行代码执行了a次，T=a 第10、11行代码的分析比较难，我们可以拆分来看while循环内for循环的执行的次数：第一次执行时for循环执行了a次，T=a，第二次执行for循环执行时a减小了1，那么for循环就执行了a-1次，T=a-1，第三次则T=a-2。可以看到这是一个等差数列，公差为1，那么就可以通过等差数列的求和公式计算，得到T=a(1+a)/2 综上分析：T=1+a+ab+1+a+a(1+a)/2，我们继续分析： 去掉常量和低阶变量为：T(n)=ab+1/2*a^2^ 去掉系数为：T(n)=O(ab+a^2^) 因为a, b的数据规模我们并不能确定，所以我们并不能合并它们，以上就是最终的时间复杂度 通过以上的分析，我们已经掌握了时间复杂度的分析法，只要将一些复杂的代码拆分成一份份简单的代码，我们就能很容易分析出其中的复杂度，不过，复杂度分析还是需要一些数学知识的。 再来看下一个 空间复杂度时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。 1234567891011void print(int n) { int i = 0; int[] a = new int[n]; for (i; i &lt;n; ++i) { a[i] = i * i; } for (i = n-1; i &gt;= 0; --i) { print out a[i] }} 跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。 我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。 小结复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2^ )。下面的函数图像展示不同复杂度函数的关系。 复杂度分析并不难，关键在于多练。","link":"/codejiaoer/codejiaoer.github.io/2022/11/06/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"}],"tags":[],"categories":[{"name":"数据结构与算法设计","slug":"数据结构与算法设计","link":"/codejiaoer/codejiaoer.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"}],"pages":[]}